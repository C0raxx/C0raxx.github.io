---
layout:     post
title:      【IDA PRO权威指南】四
subtitle:   READ
date:       2023-09-30
author:     Corax
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 【IDA PRO权威指南】
    - 【读书笔记】
---

#IDA TIL文件
IDA当中所有数据类型和函数原型信息都存储在TIL文件中。
##加载新的TIL文件
在types中按下insert，选择要加载的til文件，该文件包含的所有结构体定义都被添加到标准结构体列表当中。
##共享TIL文件
前面提过，idb实际上是一个归档文件用于保存不使用的数据库组件，而til文件是它的组件文件之一。有两种共享方法，第一种不太正规，就是将til文件由打开的数据库复制到另外一个目录当中，再通过types窗口，在任何数据库打开这个til文件。第二种是一个正式的方法，从数据库当中提取出自定义类型信息，生成一段idc脚本，用于在任何其他数据中重建自定义结构体。这种方法只能存储structures窗口列出的结构体，并不存储通过解析C头文件得到的结构体。
#C++逆向工程基础
需要涉及几个重要问题和visualC++和GUN的g++当中的一些差异。
##this指针
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122633.png)
三次调用member_func分别接受&object1，&object2，&object3三个值，同时最好把this看成所有非静态类成员函数的第一个隐藏函数。visual把this传递到ECX寄存器当中，GUN把this看做非静态成员函数的第一个参数。
从逆向来看，如果一个地址转移到ECX寄存器意味着1，文件由vis编译，并且这个函数是一个成员函数，如果同一个地址被传递给两个或更多，则这些函数全部属于同一个类层次结构。
g++代码较少调用成员函数。但是如果一个函数没有八支针作为第一个参数，他必定不是成员函数。
##虚函数和虚表
虚表:包含每个虚函数的类的表
其中包含类中每一个虚函数的指针，这些成员就是虚表指针，是类的第一个数据成员。![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122634.png)
subclass是baseclass的一个子类。而subclass拥有五个虚函数。看似baseclass拥有两个数据成员，subclass拥有三个。但前面提到任何包含虚函数的类也包含一个虚表指针。
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122635.png)
subclass中的虚表指针自baseclass继承而来。
##对象生命周期
对于全局和静态分配的对象来讲，构造函数在程序启动并进入main函数之前被调用。栈分配的对象的构造函数在对象进入声明对象的函数作用域中被调用。如果对象在程序堆中动态分配，则创建对象分为两步，第一步调用new操作符分配对象的内存。第二部调用构造函数初始化。visual在调用构造函数前确保new结果不为空值。
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122636.png)
析构函数还基本上按相反的顺序调用。
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122637.png)
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122639.png)
##名称改变
用于区分重载函数的机制。是编译器实现细节，并不属于c++语言规范。![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122640.png)
##运行时类型识别RTTI  
同样也是一个编译器实现细节。
##继承关系
主要讨论缺少RTTI信息时候用的技巧来确定C++类中的继承行为。一些思路：
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122641.png)
.
.
#交叉引用和绘图功能
交叉引用可以帮助了解代码哪些部分引用了哪里的什么指令什么数据。
##交叉引用
交叉引用xref，可以看一个有向图。
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122642.png)
是这样显示交叉引用信息
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122643.png)
这里的显示格式可以告诉我们它指向的是main函数当中提出的第0x2A（42）字节，而一个箭头标示引用位置的相对位置。
##代码交叉引用
表示一条指令将控制权转交给另一条指令。转交控制权方式称之为流。有三种基本流：普通流，跳转流和调用流。
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122644.png)

> 普通流( ordinary flow)是- -种最简单的流，它表示由一条指令到另一条指令的顺序流。 这
> 是所有非分支指令( 如ADD)的默认执行流。除了指令在反汇编代码清单中的显示顺序外，正常
> 流没有其他特殊的显示标志。如果指令A有一一个指向指令B的普通流，那么，在反汇编代码清
> 单中，指令B会紧跟在指令A后面显示。在代码清单9-1中,除➊、❷两处的指令外，其他每一
> 条指令都有一一个普通流指向紧跟在它们后面的指令。

![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122645.png)
> 指令用于调用函数,如❸处的x86ca11指令,它分配到一个调用流( call flow),表示控制权
> 被转交给目标函数。多数情况下，ca11指令也分配到-个普通流，因为大多数函数会返回到ca1l
> 之后的位置。如果IDA认为某个函数并不返回(在分析阶段确定),那么，在调用该函数时，它
> 就不会为该函数分配普通流。调用流通过在目标函数(流的目的地址)处显示交叉引用来表示。
> ca1lflow函数的反汇编代码清单如下所示:

每个无条件分支指令和条件分支指令将分配到-个跳转流( jump flow )。条件分支还分配到
普通流，以在不进人分支时对流进行控制。无条件分支并没有相关的普通流，因为它总会进入分
支。❺处的虚线表示相邻的两条指令之间并不存在普通流。跳转流与跳转目标位置显示的跳转式
交叉引用有关，如◎处所示。与调用式交叉引用一样,跳转交叉引用显示引用位置(跳转的源头)
的地址。跳转交叉引用使用后缀j (看做是Jump )。
##数据交叉引用
有写对他的读取权限
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122646.png)
有
1. 读取交叉引用
2. 写入交叉引用
3. 偏移量交叉引用
其中偏移量交叉引用，表示引用的某个位置的**地址**。虚函数当中常用。
##交叉引用列表
通过view open subviews cross-reference打开。
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122647.png)
第二种方法是突出显示一个感兴趣的名称，在菜单中jump jump to xref打开一个对话框，列出了引用选中符号的每个位置
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122648.png)
##函数调用
有一种交叉引用列表专门处理函数调用
，窗口上半部分列出了所有调用函数位置，下半部分列出当前函数做出的全部调用
![](https://typora-1321221957.cos.ap-shanghai.myqcloud.com/image1/202311021122649.png)
#绘图
##IDA外部图形（第三方）
早期使用wingraph32捆绑图形应用程序实现。但缺乏灵活性。
后期引入集成化反汇编图形模式。
没细学
.
.
.
#IDA多面孔（多平台)
MS-DOS控制台应用程序。
##控制台模式IDA
界面基本保持一致
##控制台模式的共同特性
